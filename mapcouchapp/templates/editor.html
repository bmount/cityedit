<!doctype html>

<html>
<head>
    <meta charset="utf-8">
    <title>cityedit "{{ title }}"</title>

    <script src="{{app_url}}/d3.min.js"></script>
    <script src="{{app_url}}/d3.geo.min.js"></script>
    <script src="{{app_url}}/fermata.min.js"></script>
    <script src="{{app_url}}/polymaps-couchbb.js"></script>
    <script src="{{app_url}}/polymaps.editor.js"></script>
    <script src="{{app_url}}/polymaps.viewer.js"></script>
    <script src="{{app_url}}/fabric.all.min.js"></script>
    <script src="{{app_url}}/d3.geo.tiler.js"></script>

    <style>
    #map { position: absolute; top: 50px; bottom: 1em; left: 0; right: 0; padding: 0; margin: 0; z-index: 1; }
    #canvfeature { position: absolute; top: 50px; bottom: 1em; left: 0; right: 0; padding: 0; margin: 0; z-index: 0; }
    #shape_controls, .editing_shape #doc_controls { display: none; }
    #doc_controls, .editing_shape #shape_controls { display: block; }
    
    .viewer { fill: grey; fill-opacity: 0.5; stroke: black; }
    .viewer polyline { fill: none !important; stroke-width: 3px; }
    .viewer .hover { fill-opacity: 0.25; stroke-opacity: 0.75; stroke-style: red; }
    .viewer .color0 { fill: red; stroke: grey; }
      .color0:hover { fill: red; stroke: red; }
    .viewer .color1 { fill: green; stroke: grey; }
    .viewer .color2 { fill: blue; stroke: grey; }
    .viewer .editing { stroke: red; fill-opacity: 0.05; stroke-opacity: 0.1; }
  </style>
  
</head>

<body>
  <div id="canvfeature">
    <canvas id="fabcanv"></canvas>
  </div>

<form id="doc_controls" action="{{app_url}}/_update/content/{{id}}" method="POST">
    <a href="{{app_url}}/_list/summary/by_moddate_cp">←</a>
    <input name="title" placeholder="Document title" value="{{ title }}"></input>
    <button class="save" disabled>Save</button><br>
    <a href class="add">⫀ Add Something</a> (Like what? Like 
      <a href="http://missionlocal.org/2010/04/guerrero-park-blossoms-in-a-sea-of-concrete/" 
        target="_blank">this</a>.) | (double click curbs/medians to edit) or add: &#x2619;
    <a href class="df-tree">a tree</a> &#x2619;
    <!-- Think about buttons etc 
    <img href class="df-basketball" height="50" width="50" 
        style='position:absolute;top:0px;right:50px;' 
        src="{{app_url}}/designfeatures/stbasketball.jpg" /> 
    -->   
    <a href class="df-tacos">a tacotruck</a> &#x2619;
    <a href class="df-dog">dog</a> &#x2619;
    <a href class="df-grass">grass</a> &#x2619;
    <a href class="df-fwy">freeway removal</a> &#x2619;
    <a href class="df-remove">remove image</a> &#x2619;
    <a href class="reset">reset</a> &#x2619;
    <a href class="finder">streetmap</a>
    <textarea id="geojson_content" name="content" hidden>{{ content }}</textarea>
</form>
    
  <div id="shape_controls">
    <a href class="cancel">← Cancel</a>
    <!--<a href>Fields...</a>-->
    <button class="save" type="button">Done</button><br>
    <a href class="delete">∉ Remove shape</a>
  </div>

  <div id="map"></div>

  <script>

  var __ = function (id) {return document.getElementById(id)}

  var po = org.polymaps,
      map = po.map().container(d3.select('#map').append("svg:svg").node()),
      h = window.location.hash
    map.add(po.interact());
    map.add(po.hash());
    map.add(po.grid());
    map.center({lat: h ? h.split('/')[1]: 37.7455, lon: h ? h.split('/')[2] : -122.42203}).zoom(20);
    map.zoomRange([20])

    // TODO: properly attribute whichever layer is used
    // if you're using tiles replicated from this app, attribution is optional
    map.add(po.image()
      //.url(po.url("http://{S}.sfgeo.org/sesf/tile-{Z}-{X}-{Y}/tile-{Z}-{X}-{Y}.png")
      .url(po.url("/sesf/tile-{Z}-{X}-{Y}/tile-{Z}-{X}-{Y}.png")));
      //  .hosts([1, 2, 3, 4])));

    var vector = po_metakaolin_viewer(),
      editor = po_metakaolin_editor();
    map.add(vector).add(editor);


      d3.select(vector.container()).classed('viewer', true);
      vector.on('show', function (loadEvent) {
          loadEvent.features.forEach(function (f,i) {
              d3.select(f.element).on("dblclick", function () {
                  d3.event.stopPropagation();
                  d3.event.preventDefault();
                  editGeometry(f.data.geometry);
              }).on("mouseover", function () {
                  d3.select(this).classed('hover', true);
              }).on("mouseout", function () {
                  d3.select(this).classed('hover', false);
              }).classed('color0', true).classed('editing', f.data.geometry === editingGeometry);
              //}).classed('color' + (i % 3), true).classed('editing', f.data.geometry === editingGeometry);
          });
      });

      var geoJsonEl = d3.select("#geojson_content").node(),
          featureCollection = (geoJsonEl.value) ? JSON.parse(geoJsonEl.value) : null;
          function updateFeatures() {
            var h = window.location.hash
            geoJsonEl.value = JSON.stringify(featureCollection);
            vector.features(featureCollection.features);
            d3.select('#doc_controls .save').property('disabled', false);
      }
      if (!featureCollection) {
          featureCollection = {type:"FeatureCollection", features:[]};
          updateFeatures();
      }

      // default location is san jose ave/guerrero ave pavement-to-park project, San Francisco
      map.center({lat: h ? h.split('/')[1]: 37.7455, lon: h ? h.split('/')[2] : -122.42203}).zoom(20);
      map.zoomRange([20])

      if (featureCollection.features.length) {
          //var bounds = d3.geo.bounds(featureCollection).map(function (c) { return {lon:c[0], lat:c[1]}; });
          vector.features(featureCollection.features);
          //map.extent(bounds).zoomBy(-0.25);
      }

      d3.select('#doc_controls .add').on('click', function () {
          d3.event.preventDefault();
          addFeature();
      });
      
      d3.select('#doc_controls .df-remove').on('click', function (designFeature) {
          d3.event.preventDefault();
          canvas.remove(canvas.getActiveObject());
      });
      
      // <a href class="df-save-symbol">save image</a>
      d3.select('#doc_controls .df-save-symbol').on('click', function () {
        d3.event.preventDefault();
        groupFeatureUpdate = {type:"FeatureCollection", features:[]}
        if (!editingSymbol) return;
        featureCollection.features.push({type:"FeatureCollection", features:[editingSymbol]})
        updateFeatures();
      })

      d3.select('#doc_controls .df-tree').on('click', function (designFeature) {
          d3.event.preventDefault();
          addDesignPt('treeabove.png');
      });

      d3.select('#doc_controls .df-tacos').on('click', function (designFeature) {
          d3.event.preventDefault();
          addDesignPt('tonayense.jpg');
      });

      d3.select('#doc_controls .df-dog').on('click', function (designFeature) {
          d3.event.preventDefault();
          addDesignPt('howler2.png');
      });

      d3.select('#doc_controls .df-grass').on('click', function (designFeature) {
          d3.event.preventDefault();
          addDesignPt('grass.jpg');
      });

      d3.select('#doc_controls .df-fwy').on('click', function (designFeature) {
        d3.event.preventDefault();
        var randidx = Math.floor(Math.random()*6)
        addDesignPt('wall/wall' + randidx.toString() + '.jpg');
      });

      d3.select('#doc_controls .df-basketball').on('click', function (designFeature) {
          d3.event.preventDefault();
          addDesignPt('stbasketball.jpg');
      });
      
      d3.select('#doc_controls .add_existing_curbs').on('click', function (designFeature) {
          d3.event.preventDefault();
          addCurbs();
      });
      
      d3.select('#doc_controls .reset').on('click', function () {
        d3.event.preventDefault();
        window.location.reload(true)
      });

      d3.select('#doc_controls .finder').on('click', function () {
        d3.event.preventDefault();
        var zOut = window.location.hash
        zOut = zOut.replace("#20.00/", "#18/")
        window.location = "{{app_url}}/finder.html"+zOut
      });

      d3.select('input[name=title]').on('change', function () {
          d3.select('#doc_controls .save').property('disabled', false);
      });

      d3.select('#doc_controls').on('submit', function () {
          d3.select('#doc_controls .save').property('disabled', true);
      });

      window.addEventListener('beforeunload', function () {
          if (d3.select('#doc_controls .save').property('disabled') === false) {
              return 'You have unsaved changes that will be lost.';
          }
      }, false);

      var editingSymbol = false

      function addDesignPt (designFeature) {
          // I touch no one and no one touches me
          var geom = {type:"Feature", "geometry": {type:"Point", coordinates:[]}},
              center = map.center();
          geom.properties = {}
          geom.properties.imageName = designFeature;

          symbolEditor = useCanvasEditor()
          symbolEditor(designFeature, geom)
      }

      function viewBounds (baseUrl) {
        var bounds = "/" + baseUrl + "/_design/tgs/_spatial/_list/geojson/geomsFull?bbox="+
            map.extent()[0].lon + ',' +
            map.extent()[0].lat + ',' +
            map.extent()[1].lon + ',' +
            map.extent()[1].lat
        return bounds
      }

      function addCurbs () {
        if (featureCollection.features.length === 0) { 
          d3.json(viewBounds('curblines').replace('geomsFull', 'geoms'),
            
            function (rv) {
              rv.features.forEach(function (curbline) {
                featureCollection.features.push(curbline)
                updateFeatures();
              })
            })
          }
        }

/* Dropped in favor of d3.geo.tiler approach, but maybe useful in 
   evaluating the path of street centerlines
    function loadStreetNames (f) {
      for (var i = 0; i < f.features.length; i++) {
        var feat = f.features[i],
          props = feat.data.properties
        //feat.element.setAttribute("stroke", "green")
        //feat.element.setAttribute("fill", "none")
        feat.element.setAttribute("id", "id-"+props._id)
        defLines.appendChild(feat.element)
        var labelLines = map.container().appendChild(po.svg("text"))
        labelLines.setAttribute("class", "layer")
        var txt = document.createElementNS("http://www.w3.org/1999/xlink", "textPath")
        txt.appendChild(document.createTextNode(props.properties.STREETNAME))
        txt.setAttribute("fill", "red")
        var labelPath = labelLines.appendChild(txt)
        //labelPath.setAttribute('xlink:href', '#'+props._id)
        labelPath.setAttribute('font-size', 42)
        labelPath.setAttributeNS("http://www.w3.org/1999/xlink", 'xlink:href', '#id-'+props._id)
        //map.add(labelPath)
        stLabelCache[props._id] = feat
        feat.element.setAttribute("class", "stctrln")
        console.log([props, feat])
      }
      for (var k in stLabelCache) {
      }
      stLabelCache.usable = true
      console.log(defLines)
      console.log('map')
      console.log(map)
    }
    
    

    function addStreetNames () {
      map.add(po.geoJsonLabel()
        .url("/stctrln/_design/tgs/_spatial/_list/geojson/geomsFull?bbox={G}")
        .on("load", loadStreetNames))
    }
    
    */

    function blockUnitVectors (pts, idx) {
      var rv = [0],
          anglerv = []
      for (var i = 1; i < pts.length; i++) {
        var dx = Math.abs(pts[i-1][0]-pts[i][0]),
            dy = 1.2*Math.abs(pts[i-1][1]-pts[i][1]), // TODO properly project
            l = Math.pow(Math.pow(dx, 2) + Math.pow(dy, 2), .5),
            ang = Math.atan(dy/dx) * 180 / Math.PI,
            flip = (dx >= dy)? -1: 1,
            angle = flip*ang
        rv[0] ? null: rv[0] = ang
        anglerv.push(angle)
        //coordrv.push([pts[i-1][0],pts[i][0]])
        //coordrv.push([pts[i-1][1],pts[i][1]])        
      }
      var maxrv = Math.max.apply(null, rv)
      var maxidx = rv.indexOf(maxrv)  
      return [maxidx, anglerv[maxidx]];
    }

    function tileStreetLabels () {
      // https://gist.github.com/900050
      map.add(streetLabels(viewBounds("stctrln")));

      // Custom layer implementation.
      function streetLabels(url) {

        // Create the tiler, for organizing our points into tile boundaries.
        var tiler = d3.geo.tiler()
            .zoom(20)
            .location(function(d) { return d.value; });

        // Create the base layer object, using our tile factory.
        var layer = po.layer(load);

        // Load the data. When the data comes back, reload.
        //var sameIntersection = false
        var sameIntersection = {}
        d3.json(url, function(json) {
          var rv = {}
          console.log(json)
          for (var k = 0; k < json.features.length; k++) {
            console.log(json.features[k])
            var streetName = json.features[k].properties.properties.STREETNAME;
            var blockUvs = blockUnitVectors(json.features[k].geometry.coordinates)
            var ptIdx = blockUvs[0]
            var angVal = blockUvs[1]
            var stid = 'stid-'+Math.floor(Math.random()*16777215).toString(16)
            //for (var j = 0; j < json.features[k].geometry.coordinates.length; j+=2) {
              
            /* Issue here is that street centerlines include sort of non-traffic
            lines connecting actual centerlines with undefined medians at big
            intersections. Currently looks wrong on such streets, but ok for bigger
            limiting to 1 record per .001 * .001 lon lat square works but may not show
            the area of interest/view, some variant of that comparing to center point might
            work

            var cmpCoords = [json.features[k].geometry.coordinates[ptIdx][0].toFixed(3),
            json.features[k].geometry.coordinates[ptIdx][1].toFixed(3)].toString()
            if (typeof sameIntersection[streetName] == 'undefined') {
                sameIntersection[streetName] = cmpCoords
                rv[stid] = [json.features[k].geometry.coordinates[ptIdx][0], 
                  json.features[k].geometry.coordinates[ptIdx][1], 
                  streetName, angVal]; 
            } else if (sameIntersection[streetName] == cmpCoords) {
              console.log(json.features[k])
              console.log('minifail')
              continue
            } else {   
            */

            rv[stid] = [json.features[k].geometry.coordinates[ptIdx][0], 
              json.features[k].geometry.coordinates[ptIdx][1], 
              streetName, angVal]; 
            //}
          }
          tiler.points(d3.entries(rv))
          sameIntersection = {}
          layer.reload();
        });

        // Custom tile implementation.
        function load(tile, projection) {
          projection = projection(tile).locationPoint;

          // Add an svg:g for each street.
          var g = d3.select(tile.element = po.svg("g")).selectAll("g")
              .data(tiler.tile(tile.column, tile.row, tile.zoom))
            .enter().append("svg:g")
              .attr("transform", transform);

          // Add a circle. Not using atm
          g.append("svg:circle")
              .style("fill", "none")
              //.style("fill", d3.hsl(Math.random() * 360, 1, .5))
              .attr("r", 4.5);

          // Add a label. like house: "#f5f0d0" like lot bg: "#f5f0d0"
          g.append("svg:text")
              .attr("x", 15)
              .attr("dy", ".31em")
              .attr("font-family", "Monaco")
              .attr("fill", "#527F76")
              .attr("transform", function (d) { return "rotate("+ d.value[3] +")"} )
              .text(function(d) { var ang = d.value[3]; if (typeof ang != 'undefined') return d.value[2]; });

          function transform(d) {
            d = projection({lon: d.value[0], lat: d.value[1]});
            return "translate(" + d.x + "," + d.y + ")";
          }
        }

        return layer;
      }
    }



  function exitCanvasEditor () {
    __('map').style.zIndex = 1
    canvas.clear()
  }

  function useCanvasEditor () { 
    __('map').style.zIndex = -1
    var fabricCanvas = __('fabcanv')
    if (!fabricCanvas.getAttribute("initialized")) {
      fabricCanvas.setAttribute('height', map.size().y)
      fabricCanvas.setAttribute('width', map.size().x)
      fabricCanvas.setAttribute("initialized", "yes")
      var canvas = window.canvas = new fabric.Canvas('fabcanv');
    }
    else {
      var canvas = window.canvas
    }

    var symbolFeature = function (designFeature, geom) {
      editingSymbol = geom
      if (designFeature.match(/png$|jpg$|jpeg$/)) {
        fabric.Image.fromURL('{{app_url}}/designfeatures/'+designFeature, function (img) {
          d3.select(document.body).classed('editing_shape', true);
          img.scaleToWidth(120)
          img.set({left:500, top:200})
          canvas.observe({"mouse:up" : function (e) {
            var trgt = e.memo.target
            console.log('e')
            console.log(e)
            // hardcoding 50 px top margin for the moment:
            //var upPt = map.pointLocation({x: e.memo.e.clientX, y: e.memo.e.clientY-50})
            var upPt = map.pointLocation({x: trgt.left, y: trgt.top-50})
            editingSymbol.geometry.coordinates = [upPt.lon, upPt.lat]
            editingSymbol.properties.userData = e.memo.target
            }
          })
          canvas.add(img)
        })
      }
      canvas.renderAll()
    }
    return symbolFeature
  }

      function addFeature() {
          var geom = {type:"Polygon", coordinates:[[]]},
              size = 0.00005125,
              center = map.center();
          geom.coordinates[0].push([center.lon - size, center.lat + size]);
          geom.coordinates[0].push([center.lon + size, center.lat + size]);
          geom.coordinates[0].push([center.lon + size, center.lat - size]);
          geom.coordinates[0].push([center.lon - size, center.lat - size]);
          geom.coordinates[0].push([center.lon - size, center.lat + size]);
          if (0) {
              geom.type = (1) ? "LineString" : "MultiPoint";
              geom.coordinates = geom.coordinates[0];
              geom.coordinates.pop();
          } else if (1) {
              //geom = geom
              // 
              geom = {type:"GeometryCollection", geometries:[geom]};
          }
          featureCollection.features.push({type:"Feature", properties:null, geometry:geom});
          updateFeatures();
          editGeometry(geom);
      }

      var editingGeometry = null;
      function editGeometry(geom) {
          d3.select(document.body).classed('editing_shape', true);
          editor.geometry(editingGeometry = geom);
          vector.reshow();
      }

      function saveEdits(sym) {
        if (typeof sym == 'object') {
          if (typeof sym.geometry == 'object') {
            featureCollection.features.push(sym)
            updateFeatures()
            finishEditing()
            exitCanvasEditor()
            return
          }
        }

        var newGeometry = editor.geometry();
        Object.keys(newGeometry).forEach(function (key) {
            editingGeometry[key] = newGeometry[key];
            if (key === "geometries") delete editingGeometry["coordinates"];
            if (key === "coordinates") delete editingGeometry["geometries"];
        });
        updateFeatures();
        finishEditing();
      }

      function deleteEdited() {
          var removedFeature = featureCollection.features.filter(function (f) { return f.geometry === editingGeometry; })[0];
          featureCollection.features = featureCollection.features.filter(function (f) { return f !== removedFeature; });
          updateFeatures();
          finishEditing();
      }
      function finishEditing() {
          editor.geometry(editingGeometry = null);
          vector.reshow();
          d3.select(document.body).classed('editing_shape', false);
      }
      d3.select('#shape_controls .cancel').on('click', function () {
          d3.event.preventDefault();
          finishEditing();
      });
      d3.select('#shape_controls .save').on('click', function () {
        d3.event.preventDefault();
          if (typeof editingSymbol === 'object') {
            saveEdits(editingSymbol)
            editingSymbol = false
          } else { 
            saveEdits() 
          }
      });

      d3.select('#shape_controls .delete').on('click', function () {
          d3.event.preventDefault();
          deleteEdited();
      });

      document.addEventListener("DOMContentLoaded", addCurbs, false)
      document.addEventListener("DOMContentLoaded", tileStreetLabels, false)

  </script>
</body>
</html>
