<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Metakaolin — Edit "{{ title }}"</title>
    <!-- -->
    <script src="{{app_url}}/d3.min.js"></script>
    <script src="{{app_url}}/d3.geo.min.js"></script>
    <script src="{{app_url}}/fermata.min.js"></script>
    <script src="{{app_url}}/polymaps-couchbb.js"></script>
    <script src="{{app_url}}/polymaps.editor.js"></script>
    <script src="{{app_url}}/polymaps.viewer.js"></script>
    <script src="{{app_url}}/fabric.all.min.js"></script>
    <!-- -->
    
    <!-- temporary: allow quicker local development
    <script src="../_attachments/d3.min.js"></script>
    <script src="../_attachments/d3.geo.min.js"></script>
    <script src="../_attachments/fermata.min.js"></script>
    <script src="../_attachments/polymaps.min.js"></script>
    <script src="../_attachments/polymaps.editor.js"></script>
    -->

    <style>
        #map { position: absolute; top: 4em; bottom: 1em; left: 0; right: 0; padding: 0; margin: 0; z-index: 1; }
        #featureEd { position: absolute; top: 4em; bottom: 1em; left: 0; right: 0; padding: 0; margin: 0; z-index: 0; }
        #shape_controls, .editing_shape #doc_controls { display: none; }
        #doc_controls, .editing_shape #shape_controls { display: block; }
        
        .viewer { fill: grey; fill-opacity: 0.5; stroke: black; }
        .viewer polyline { fill: none !important; stroke-width: 3px; }
        .viewer .hover { fill-opacity: 0.25; stroke-opacity: 0.75; }
        .viewer .color0 { fill: red; stroke: red; }
        .viewer .color1 { fill: green; stroke: green; }
        .viewer .color2 { fill: blue; stroke: blue; }
        .viewer .editing { fill-opacity: 0.05; stroke-opacity: 0.1; }
    </style>
</head>

<body>
  <div id="featureEd">
    <canvas id="fabcanv"></canvas>
</div>

    <form id="doc_controls" action="{{app_url}}/_update/content/{{id}}" method="POST">
        <a href="{{app_url}}/_list/summary/by_moddate_cp">←</a>
        <!--<a href="{{app_url}}/_show/viewer/{{id}}">Cancel</a>-->
        <!--<a href="{{app_url}}/_show/files/{{id}}">Files...</a>-->
        <input name="title" placeholder="Document title" value="{{ title }}"></input>
        <button class="save" disabled>Save</button><br>
        <a href class="add">⫀ Add Something</a> (Like what? Like <a href="http://missionlocal.org/2010/04/guerrero-park-blossoms-in-a-sea-of-concrete/" target="_blank">this</a>.) | 
        <a href class="add_design_element">add a point</a> | 
        <a href class="add_existing_curbs">MOVE THE EXISTING CURBS</a> (double click on curb lines to edit)
        <a href class="df-tree">add a tree</a>
        <a href class="df-tacos">add tacos</a>
        <a href class="done_design_element">reset</a>
        <textarea id="geojson_content" name="content" hidden>{{ content }}</textarea>
    </form>
    <div id="shape_controls">
        <a href class="cancel">← Cancel</a>
        <!--<a href>Fields...</a>-->
        <button class="save" type="button">Done</button><br>
        <a href class="delete">∉ Remove shape</a>
    </div>

    <div id="map"></div>

    <script>

    var __ = function (id) {return document.getElementById(id)}

    function useCanvasEditor () { 
      (function () {
        __('map').style.zIndex = -1
      })()
      var fabricCanvas = __('fabcanv')
      console.log(fabricCanvas)
      console.log(fabricCanvas.initialized)
      if (!fabricCanvas.getAttribute("initialized")) {
        fabricCanvas.setAttribute('height', map.size().y)
        fabricCanvas.setAttribute('width', map.size().x)
        fabricCanvas.setAttribute("initialized", "yes")
        var canvas = window.canvas = new fabric.Canvas('fabcanv');
      }
      else {
        var canvas = window.canvas
      }
      var symbolFeature = function (designFeature) {
        if (designFeature.indexOf('png') != -1) {
        //canvas.add(new fabric.Circle({ radius: 30, fill: '#f55', top: 100, left: 100 }));
          fabric.Image.fromURL('{{app_url}}/designfeatures/'+designFeature, function (img) {
            canvas.add(img)
          })
        }
        if (designFeature.indexOf('jpg') != -1) {
        //canvas.add(new fabric.Circle({ radius: 30, fill: '#f55', top: 100, left: 100 }));
          fabric.Image.fromURL('{{app_url}}/designfeatures/'+designFeature, function (img) {
            canvas.add(img)
          })
        }

        //fabric.Image.fromURL('{{app_url}}/designfeatures/treeabove.png', function (img) {
        //  canvas.add(img)
        //})
        if (designFeature.indexOf('svg') != -1) {
          fabric.loadSVGFromURL("{{app_url}}/designfeatures/"+designFeature, function(objects) {
            var pathgroup = new fabric.PathGroup(objects)
            canvas.add(pathgroup)
            //.centerObj(pathgroup)
            updateComplexity()
          })
        }
        canvas.renderAll()
      }
      return symbolFeature
    }

      var po = org.polymaps,
          map = po.map().container(d3.select('#map').append("svg:svg").node()),
          h = window.location.hash
        map.add(po.interact());
        map.add(po.hash());
        map.add(po.grid());
        map.center({lat: h ? h.split('/')[1]: 37.7455, lon: h ? h.split('/')[2] : -122.42203}).zoom(20);
        map.zoomRange([20])

        // TODO: properly attribute whichever layer is used
        map.add(po.image()
          .url(po.url("http://{S}.sfgeo.org/cetiles2/tile-{Z}-{X}-{Y}/tile-{Z}-{X}-{Y}.png")
          //.url(po.url("http://localhost:5984/zt6/tile-{Z}-{X}-{Y}/tile-{Z}-{X}-{Y}.png")));
            .hosts([1, 2, 3, 4])));

        var vector = po_metakaolin_viewer(),
            editor = po_metakaolin_editor();
        map.add(vector).add(editor);

        d3.select(vector.container()).classed('viewer', true);
        vector.on('show', function (loadEvent) {
            loadEvent.features.forEach(function (f,i) {
                d3.select(f.element).on("dblclick", function () {
                    d3.event.stopPropagation();
                    d3.event.preventDefault();
                    editGeometry(f.data.geometry);
                }).on("mouseover", function () {
                    d3.select(this).classed('hover', true);
                }).on("mouseout", function () {
                    d3.select(this).classed('hover', false);
                }).classed('color' + (i % 3), true).classed('editing', f.data.geometry === editingGeometry);
            });
        });

        var geoJsonEl = d3.select("#geojson_content").node(),
            featureCollection = (geoJsonEl.value) ? JSON.parse(geoJsonEl.value) : null;
            function updateFeatures() {
              var h = window.location.hash
              geoJsonEl.value = JSON.stringify(featureCollection);
              vector.features(featureCollection.features);
              d3.select('#doc_controls .save').property('disabled', false);
        }
        if (!featureCollection) {
            featureCollection = {type:"FeatureCollection", features:[]};
            updateFeatures();
        }

        // default location is san jose ave/guerrero ave pavement-to-park project, San Francisco

        map.center({lat: h ? h.split('/')[1]: 37.7455, lon: h ? h.split('/')[2] : -122.42203}).zoom(20);
        map.zoomRange([20])

        if (featureCollection.features.length) {
            //var bounds = d3.geo.bounds(featureCollection).map(function (c) { return {lon:c[0], lat:c[1]}; });
            vector.features(featureCollection.features);
            //map.extent(bounds).zoomBy(-0.25);
        }

        /*    
        } else if (navigator.geolocation) navigator.geolocation.getCurrentPosition(function (p) {
            map.center({lat:p.coords.latitude, lon:p.coords.longitude}).zoom(14);
          });
        */

        d3.select('#doc_controls .add').on('click', function () {
            d3.event.preventDefault();
            addFeature();
        });

        d3.select('#doc_controls .df-tree').on('click', function (designFeature) {
            d3.event.preventDefault();
            addDesignPt('treeabove.png');
        });

        d3.select('#doc_controls .df-tacos').on('click', function (designFeature) {
            d3.event.preventDefault();
            addDesignPt('tonayense.jpg');
        });

        d3.select('#doc_controls .add_design_element').on('click', function (designFeature) {
            d3.event.preventDefault();
            addDesignPt('treeabove.png');
        });
        
        d3.select('#doc_controls .add_existing_curbs').on('click', function (designFeature) {
            d3.event.preventDefault();
            addCurbs();
        });

        d3.select('input[name=title]').on('change', function () {
            d3.select('#doc_controls .save').property('disabled', false);
        });
        d3.select('#doc_controls').on('submit', function () {
            d3.select('#doc_controls .save').property('disabled', true);
        });
        window.addEventListener('beforeunload', function () {
            if (d3.select('#doc_controls .save').property('disabled') === false) {
                return 'You have unsaved changes that will be lost.';
            }
        }, false);

        function addDesignPt (designFeature) {
            // I touch no one and no one touches me
            var geom = {type:"Point", coordinates:[]},
                size = 0.00005125,
                center = map.center();
            console.log(map.center());    
            geom.properties = {}
            geom.properties.imageName = designFeature;
            geom.coordinates = [center.lon, center.lat];
            geom = {type:"GeometryCollection", geometries:[geom]};
            featureCollection.features.push({type:"Feature", properties:null, geometry:geom});
            /*function showFeature (tile, proj) {
              proj = proj(tile);
              return;
            }*/
            //map.add(po.layer(showFeature).tile(false));
            //updateFeatures();
            //editGeometry(geom);
            symbolEditor = useCanvasEditor()
            symbolEditor(designFeature)
        }

        function addCurbs () { 
          d3.json("/curblines/_design/tgs/_spatial/_list/geojson/geoms?bbox="+
            map.extent()[0].lon + ',' +
            map.extent()[0].lat + ',' +
            map.extent()[1].lon + ',' +
            map.extent()[1].lat, 
            
            function (rv) {
              rv.features.forEach(function (curbline) {
                featureCollection.features.push(curbline)
                //console.log(curbline)
                updateFeatures();
                //editGeometry();
              })
            })
          }
          
          /*        
          
          // some version of this with a styling load function is probably 
          // good for a full svg background map
          map.add(po.geoJson()
              .url("/curblines/_design/tgs/_spatial/_list/geojson/geoms?bbox={G}")
              //.url("/citylots/_design/tgs/_spatial/_list/geojson/geoms?bbox={G}")
              .tile(true)
              .on("load", function (e) {
                // make like the city presentation document color scheme
                return; 
              }))
          
          */

        function addFeature() {
            var geom = {type:"Polygon", coordinates:[[]]},
                size = 0.00005125,
                center = map.center();
            geom.coordinates[0].push([center.lon - size, center.lat + size]);
            geom.coordinates[0].push([center.lon + size, center.lat + size]);
            geom.coordinates[0].push([center.lon + size, center.lat - size]);
            geom.coordinates[0].push([center.lon - size, center.lat - size]);
            geom.coordinates[0].push([center.lon - size, center.lat + size]);
            if (0) {
                geom.type = (1) ? "LineString" : "MultiPoint";
                geom.coordinates = geom.coordinates[0];
                geom.coordinates.pop();
            } else if (1) {
                geom = {type:"GeometryCollection", geometries:[geom]};
            }
            featureCollection.features.push({type:"Feature", properties:null, geometry:geom});
            updateFeatures();
            editGeometry(geom);
        }

        var editingGeometry = null;
        function editGeometry(geom) {
            d3.select(document.body).classed('editing_shape', true);
            editor.geometry(editingGeometry = geom);
            vector.reshow();
        }

        function saveEdits() {
            var newGeometry = editor.geometry();
            Object.keys(newGeometry).forEach(function (key) {
                editingGeometry[key] = newGeometry[key];
                if (key === "geometries") delete editingGeometry["coordinates"];
                if (key === "coordinates") delete editingGeometry["geometries"];
            });
            updateFeatures();
            finishEditing();
        }

        function deleteEdited() {
            var removedFeature = featureCollection.features.filter(function (f) { return f.geometry === editingGeometry; })[0];
            console.log(featureCollection.features.length);
            featureCollection.features = featureCollection.features.filter(function (f) { return f !== removedFeature; });
            console.log(featureCollection.features.length);
            updateFeatures();
            finishEditing();
        }
        function finishEditing() {
            editor.geometry(editingGeometry = null);
            vector.reshow();
            d3.select(document.body).classed('editing_shape', false);
        }
        d3.select('#shape_controls .cancel').on('click', function () {
            d3.event.preventDefault();
            finishEditing();
        });
        d3.select('#shape_controls .save').on('click', function () {
            d3.event.preventDefault();
            saveEdits();
        });
        d3.select('#shape_controls .delete').on('click', function () {
            d3.event.preventDefault();
            deleteEdited();
        });
    </script>
</body>
</html>
